(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{75:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return c}));var r=t(3),a=t(7),o=(t(0),t(101)),i={id:"index",title:"Core",sidebar_label:"Core",slug:"/"},l={unversionedId:"index",id:"index",isDocsHomePage:!1,title:"Core",description:"Do.Try",source:"@site/docs/index.md",slug:"/",permalink:"/AndcultureCode.CSharp.Core/docs/",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/index.md",version:"current",sidebar_label:"Core",sidebar:"primary"},s=[{value:"Do.Try",id:"dotry",children:[{value:"Do",id:"do",children:[]},{value:"Try",id:"try",children:[]},{value:"Then",id:"then",children:[]}]}],d={toc:s};function c(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"dotry"},"Do.Try"),Object(o.b)("p",null,Object(o.b)("a",{parentName:"p",href:"https://mattwarren.org/2016/12/20/Why-Exceptions-should-be-Exceptional/"},"Exceptions should be exceptional"),".\nNormal flow control should leverage error handling and exceptions remain rare. This library provides syntactic sugar\nto employ the .NET Framework ",Object(o.b)("inlineCode",{parentName:"p"},"TryXXX()")," pattern by way of a class called ",Object(o.b)("inlineCode",{parentName:"p"},"Do"),"."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Do")," class is accompanied by a series of static and extension methods to essentially management\nstandard C# try/catch boilerplate and provide a safe guard against an unhandled exceptions\nthat otherwise end the normal flow of execution."),Object(o.b)("p",null,"Below is documentation on the various methods available."),Object(o.b)("h3",{id:"do"},"Do"),Object(o.b)("p",null,"All of the methods to follow stem from ",Object(o.b)("inlineCode",{parentName:"p"},"Do"),". While you can instantiate your own instance with the\n",Object(o.b)("inlineCode",{parentName:"p"},"new")," keyword ",Object(o.b)("inlineCode",{parentName:"p"},"new Do(delegateFunction)"),", the preferred method to interact with this pattern\nis through the available static methods and extensions methods of ",Object(o.b)("inlineCode",{parentName:"p"},"Do"),"."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"public IResult<bool> Validate() => Do<bool>.Try((r) =>\n{\n    // Validation logic\n    return true;\n}).Result;\n")),Object(o.b)("p",null,"At the end of the day, ",Object(o.b)("inlineCode",{parentName:"p"},"Do.Try")," is simplifying the use of ",Object(o.b)("inlineCode",{parentName:"p"},"try/catch"),". Through the use of expression\nbodies and the ",Object(o.b)("inlineCode",{parentName:"p"},"IResult"),", exceptions are handled more gracefully and their result standardized."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Do")," object contains information about the work being attempted (",Object(o.b)("inlineCode",{parentName:"p"},"Workload"),") and its results\n(",Object(o.b)("inlineCode",{parentName:"p"},"Result"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Exception"),")."),Object(o.b)("h3",{id:"try"},"Try"),Object(o.b)("p",null,"The most commonly used method of ",Object(o.b)("inlineCode",{parentName:"p"},"Do")," is the ",Object(o.b)("inlineCode",{parentName:"p"},"Try")," static method. This method and its various\noverloads provide a simplified entry point into the pattern."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},'/// <summary>\n/// Attempts to run the provided delegate function\n/// </summary>\n/// <param name="workload">Single unit of work to attempt</param>\npublic static Do<T> Try(Func<IResult<T>, T> workload);\npublic static Do<T> Try(ILogger logger, Func<IResult<T>, T> workload);\npublic static Do<T> Try(ILogger logger, uint retry, Func<IResult<T>, T> workload);\n')),Object(o.b)("p",null,"Married with the use of C# expression bodies, the ",Object(o.b)("inlineCode",{parentName:"p"},"Do<T>.Try")," call can be written in a way that\nmaintains the profile of standard method bodies."),Object(o.b)("h4",{id:"without-expression-bodies"},"Without Expression Bodies"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"// Long hand\npublic IResult<bool> Validate()\n{\n    var result = Do<bool>.Try((r) =>\n    {\n        // Validation logic\n        return true;\n    });\n\n    return result;\n}\n\n// Single line return\npublic IResult<bool> Validate()\n{\n    return Do<bool>.Try((r) =>\n    {\n        // Validation logic\n        return true;\n    }).Result;\n}\n")),Object(o.b)("h4",{id:"c-expression-bodies"},"C# Expression Bodies"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"public IResult<bool> Validate() => Do<bool>.Try((r) =>\n{\n    // Validation logic\n    return true;\n}).Result;\n")),Object(o.b)("h3",{id:"then"},"Then"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},'/// <summary>\n/// Chainable method to perform additional pieces of work beyond an initial try\n/// </summary>\n/// <param name="workload">Single unit of work to attempt</param>\n/// <param name="skipIfErrors">Provided work will be ignored if errors exist</param>\npublic Do<T> Then(Func<IResult<T>, T> workload, bool skipIfErrors = true);\n')),Object(o.b)("p",null,"There are scenarios, such as; argument validation, preloading data, etc... where preliminary work\nneeds to be done before getting to the concern of your method. Naturally, we turn to writing small\nbit sized functions to handle each of these concerns. The path forward with ",Object(o.b)("inlineCode",{parentName:"p"},"Do<T>.Try")," alone tends\nto lead to a series of somewhat boilerplate error handling."),Object(o.b)("h4",{id:"common-boilerplate-without-then"},"Common boilerplate without ",Object(o.b)("inlineCode",{parentName:"h4"},"Then")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},'public IResult<bool> Validate(long id) => Do<bool>.Try((r) =>\n{\n    // Example of common result handling boilerplate\n    var argumentResult = ValidateArguments(id);\n    if (argumentResult.HasErrors)\n    {\n        r.AddErrors(argumentResult);\n        return false;\n    }\n\n    // Additional method calls and/ or validation logic\n\n    return true;\n}).Result;\n\nprivate IResult<bool> ValidateArguments(long id) => Do<bool>.Try((r) =>\n{\n    if (id <= 0)\n    {\n        r.AddError(Errors.InvalidArgument(nameof(id)), "must be greater than zero");\n    }\n\n    return !r.HasErrors;\n}).Result;\n')),Object(o.b)("h4",{id:"chaining-with-and-without-arguments-using-then"},"Chaining with and without arguments using ",Object(o.b)("inlineCode",{parentName:"h4"},"Then")),Object(o.b)("p",null,"While there are situationally clever ways to cut down on this boilerplate, there is no clear path\nforward with ",Object(o.b)("inlineCode",{parentName:"p"},"Try")," alone."),Object(o.b)("p",null,"This is where the chainable ",Object(o.b)("inlineCode",{parentName:"p"},"Then")," method comes into play. Levering ",Object(o.b)("inlineCode",{parentName:"p"},"Do.Try.Then")," you can fluently\ncompose your IResult handling methods without the common boilerplate."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},'public IResult<bool> Validate(long id) => Do<bool>\n  .Try(ValidationMethodWithoutArguments)\n  .Then((r) => ValidateArguments(r, id))\n  .Then((r) =>\n{\n    // additonal validation logic\n\n    return true;\n}).Result;\n\nprivate bool ValidationMethodWithoutArguments(IResult<bool> r)\n{\n    if (_isMyFeatureEnabled)\n    {\n        r.AddError(Errors.FeaturedDisabled(nameof(_isMyFeatureEnabled), "is disabled"));\n    }\n\n    return !r.HasErrors;\n}\n\n// Notice the method signature simplification\nprivate bool ValidateArguments(IResult<bool> r, long id)\n{\n    if (id <= 0)\n    {\n        r.AddError(Errors.InvalidArgument(nameof(id)), "must be greater than zero");\n    }\n\n    return !r.HasErrors;\n}\n')),Object(o.b)("p",null,"Following this approach, in our contrived example where our concern is validation, there\nmay very well likely be entirely composite methods/functions."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"public IResult<bool> Validate(long id, string name) => Do<bool>\n  .Try(ValidationMethodWithoutArguments)\n  .Then((r) => ValidateId(r, id))\n  .Then((r) => ValidateName(r, name))\n  .Result;\n")),Object(o.b)("h4",{id:"short-circuiting-the-chain-with-skipiferrors"},"Short-circuiting the chain with ",Object(o.b)("inlineCode",{parentName:"h4"},"skipIfErrors")),Object(o.b)("p",null,"By default, delegate functions provided to ",Object(o.b)("inlineCode",{parentName:"p"},"Then")," will ",Object(o.b)("em",{parentName:"p"},"NOT")," be executed if the associated ",Object(o.b)("inlineCode",{parentName:"p"},"IResult"),"\nhas errors. In some scenarios, you may desire to call a series of functions before determing the\nresult."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"public IResult<bool> Validate(long id, string name) => Do<bool>\n  .Try((r) => ValidateId(r, id), skipIfErrors: false)\n  .Then((r) => ValidateName(r, name), skipIfErrors: false)\n  .Then((r) => !r.HasErrors, skipIfErrors: false) // <-- Falls through allowing our last `then` to determine the result\n  .Result;\n")))}c.isMDXComponent=!0}}]);